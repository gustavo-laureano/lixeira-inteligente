<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Controle Virtual - Lixeira Inteligente</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none; /* Impede seleção de texto */
            user-select: none;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overscroll-behavior-y: contain; 
        }

        .container {
            background: white;
            padding: 60px;
            max-width: 600px;
            width: 100%;
            border: 1px solid #ddd;
            position: relative;
            z-index: 10;
            display: grid;

            gap: 12px;
            align-items: start;
        }

        h1 {
            font-size: 24px;
            font-weight: 400;
            color: #000;
            margin-bottom: 30px;
            text-align: center;
        }

        .status-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #eee;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ccc;
        }

        .status-dot.connected {
            background: #000;
        }

        .status-text {
            font-size: 14px;
            color: #666;
        }

        .latency-info {
            font-size: 12px;
            color: #999;
        }

        .latency-value {
            color: #000;
        }

        .controls-section {
            margin-bottom: 30px;
        }

        .section-title {
            font-size: 12px;
            font-weight: 400;
            color: #999;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-grid-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .btn {
            padding: 16px;
            font-size: 14px;
            font-weight: 400;
            border: 1px solid #ddd;
            background: white;
            color: #000;
            cursor: pointer;
            transition: background 0.1s;
            touch-action: manipulation;
        }

        .btn:active, .btn.active {
            background: #f0f0f0;
        }

        .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-stop {
            background: #ffebee;
            border-color: #f44336;
        }
        
        .btn-stop:active, .btn-stop.active {
            background: #f44336;
            color: white;
        }

        .btn-test {
            width: 100%;
            margin-top: 15px;
        }

        .config-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 1px solid #eee;
        }
        .config-input-group { margin-bottom: 12px; }
        .config-input-group label { display: block; font-size: 12px; color: #999; margin-bottom: 6px; }
        .config-input-group input { width: 100%; padding: 10px; border: 1px solid #ddd; font-size: 14px; background: white; }
        .config-input-group input:focus { outline: none; border-color: #000; }
        .btn-connect { width: 100%; padding: 12px; background: #000; color: white; font-size: 14px; font-weight: 400; border: none; cursor: pointer; transition: opacity 0.1s; }
        .btn-connect:hover { opacity: 0.8; }
        .btn-connect:disabled { opacity: 0.3; cursor: not-allowed; }

        .joystick-row {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #joystick-zone {
            width: 240px;
            height: 240px;
            background: rgba(0, 0, 0, 0.08);
            border-radius: 50%;
            display: block;
            position: relative;
            z-index: 1000;
            margin: 0 auto;
        }

        .nipple .front {
            background: rgba(0, 0, 0, 0.4) !important;
            border: 2px solid white;
        }
        .nipple .back {
            background: rgba(255, 255, 255, 0.2) !important;
        }
    </style>
</head>
<body>
    
    <div class="container">
 		<h1>Controle Vetorial</h1>
 
 		<div class="status-section">
 			<div class="status-indicator">
 				<div class="status-dot" id="statusDot"></div>
 				<span class="status-text" id="statusText">Desconectado</span>
 			</div>
 			<div class="latency-info">
 				<span class="latency-value" id="latencyValue">--</span> ms
 			</div>
 		</div>
 
 		<div class="controls-section">
 			<div class="section-title">Rotação (Teclado: Q/E)</div>
 			<div class="control-grid-actions">
 				<button class="btn" id="btnQ" data-cmd="q">Girar Esq</button>
 				<button class="btn btn-stop" id="btnStop" data-cmd="x">PARAR</button>
 				<button class="btn" id="btnE" data-cmd="e">Girar Dir</button>
 			</div>
 			<button class="btn btn-test" id="btnTestLatency">Testar Latência</button>
 		</div>
 
        <div>
        <div id="joystick-zone"></div>
        </div>
 		<div class="config-section">
 			<div class="config-input-group">
 				<label for="serverInput">Servidor</label>
 				<input type="text" id="serverInput" placeholder="ws://localhost:8000/ws/controller" value="ws://localhost:8000/ws/controller">
 			</div>
 			<button class="btn-connect" id="btnConnect">Conectar</button>
 		</div>
 	</div>
 
 	<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>
 
 	<script>
        class RobotController {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.pingStartTime = null;
                
                this.vector = { vy: 0.0, vx: 0.0, vrot: 0.0 };
                this.keysPressed = new Set(); // Para rotação
                this.sendLoopInterval = null;
                this.joystickManager = null; // Armazena o 'manager' do nipplejs

                this.keyMap = {
                    'q': { axis: 'vrot', value: -1.0 }, // Girar Esquerda
                    'e': { axis: 'vrot', value: 1.0 }  // Girar Direita
                };
                
                this.statusDot = document.getElementById('statusDot');
                this.statusText = document.getElementById('statusText');
                this.latencyValue = document.getElementById('latencyValue');
                this.serverInput = document.getElementById('serverInput');
                this.btnConnect = document.getElementById('btnConnect');
                this.btnQ = document.getElementById('btnQ');
                this.btnE = document.getElementById('btnE');
                this.btnStop = document.getElementById('btnStop');
                this.btnTestLatency = document.getElementById('btnTestLatency');
                
                this.initEventListeners();
                this.updateStatus(false);
            }
            
            initJoystick() {
                // Verifica se a biblioteca foi carregada corretamente
                if (typeof nipplejs === 'undefined') {
                    console.error('NippleJS não carregou!');
                    alert('Erro: Biblioteca do Joystick não carregou.');
                    return;
                }
                
                const options = {
                    zone: document.getElementById('joystick-zone'),
                    mode: 'static', 
                    position: { left: '50%', top: '50%' },
                    color: 'rgba(0,0,0,0.5)',
                    size: 150,
                    threshold: 0.1,
                    fadeTime: 250
                };
                
                this.joystickManager = nipplejs.create(options);
                
                // Pega o único joystick criado
                const joystick = this.joystickManager.get();

                joystick.on('move', (evt, data) => {
                    if (data.vector) {
                        this.vector.vx = data.vector.x;
                        this.vector.vy = data.vector.y; 
                    }
                });

                joystick.on('end', () => {
                    this.vector.vx = 0.0;
                    this.vector.vy = 0.0;
                });
            }

            initEventListeners() {
                this.btnConnect.addEventListener('click', () => {
                    this.isConnected ? this.disconnect() : this.connect();
                });
                
                this.btnTestLatency.addEventListener('click', () => this.testLatency());

                const stopAction = (e) => {
                    e.preventDefault();
                    this.vector = { vy: 0.0, vx: 0.0, vrot: 0.0 };
                    this.keysPressed.clear();
                    
                    // Reseta visualmente o joystick
                    if (this.joystickManager) {
                        // Acessa o nipple através do manager
                        const nipple = this.joystickManager.get(0);
                        if (nipple && nipple.ui.front) {
                            nipple.ui.front.style.transform = 'translate(0px, 0px)';
                        }
                    }
                    
                    this.sendVector(); // Envia parada imediatamente
                };
                this.btnStop.addEventListener('mousedown', stopAction);
                this.btnStop.addEventListener('touchstart', stopAction, { passive: false });


                // Teclado para ROTAÇÃO ('q', 'e')
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT' || e.repeat) return;
                    const key = e.key.toLowerCase();
                    if (this.keyMap[key]) {
                        e.preventDefault();
                        this.keysPressed.add(key);
                        if (key === 'q') this.btnQ.classList.add('active');
                        if (key === 'e') this.btnE.classList.add('active');
                    }
                });

                document.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (this.keyMap[key]) {
                        e.preventDefault();
                        this.keysPressed.delete(key);
                        if (key === 'q') this.btnQ.classList.remove('active');
                        if (key === 'e') this.btnE.classList.remove('active');
                    }
                });
                
                // Botões de Rotação (para Mobile)
                const setupButton = (btn, key) => {
                    const press = (e) => {
                        e.preventDefault();
                        this.keysPressed.add(key);
                        btn.classList.add('active');
                    };
                    const release = (e) => {
                        e.preventDefault();
                        this.keysPressed.delete(key);
                        btn.classList.remove('active');
                    };
                    btn.addEventListener('mousedown', press);
                    btn.addEventListener('mouseup', release);
                    btn.addEventListener('mouseleave', release); 
                    btn.addEventListener('touchstart', press, { passive: false });
                    btn.addEventListener('touchend', release, { passive: false });
                };
                
                setupButton(this.btnQ, 'q');
                setupButton(this.btnE, 'e');
            }
            
            startSendLoop() {
                if (this.sendLoopInterval) return; 
                
                this.sendLoopInterval = setInterval(() => {
                    
                    this.vector.vrot = 0.0;
                    if (this.keysPressed.has('q')) {
                        this.vector.vrot = -1.0;
                    } else if (this.keysPressed.has('e')) {
                        this.vector.vrot = 1.0;
                    }
                    
                    this.sendVector();
                    
                }, 50); // 20 Hz
            }

            stopSendLoop() {
                if (this.sendLoopInterval) {
                    clearInterval(this.sendLoopInterval);
                    this.sendLoopInterval = null;
                }
                this.vector = { vy: 0.0, vx: 0.0, vrot: 0.0 };
                this.sendVector();
            }
            
            sendVector() {
                const { vy, vx, vrot } = this.vector;
                const cmd = `V:${vy.toFixed(2)},${vx.toFixed(2)},${vrot.toFixed(2)}`;
                this.sendCommand(cmd);
            }
            
            connect() {
                let serverUri = this.serverInput.value.trim();
                
                if (!serverUri) { alert('Por favor, insira a URI do servidor'); return; }
                if (serverUri.startsWith('http://')) serverUri = serverUri.replace('http://', 'ws://');
                if (serverUri.startsWith('https://')) serverUri = serverUri.replace('https://', 'wss://');
                if (!serverUri.startsWith('ws://') && !serverUri.startsWith('wss://')) {
                    alert('URI inválida! Use ws:// ou wss://');
                    return;
                }

                try {
                    console.log(`Conectando a: ${serverUri}`);
                    this.ws = new WebSocket(serverUri);
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket conectado');
                        this.isConnected = true;
                        this.updateStatus(true);
                        this.initJoystick(); // <-- Inicializa o joystick AQUI
                        this.startSendLoop(); 
                    };

                    this.ws.onmessage = (event) => {
                        const message = event.data;
                        if (message === 'pong' && this.pingStartTime !== null) {
                            const latency = performance.now() - this.pingStartTime;
                            this.latencyValue.textContent = latency.toFixed(1);
                            this.pingStartTime = null;
                        }
                    };

                    this.ws.onerror = (error) => {
                        console.error('Erro WebSocket:', error);
                        this.updateStatus(false);
                    };

                    this.ws.onclose = (event) => {
                        console.log('WebSocket desconectado');
                        this.isConnected = false;
                        this.updateStatus(false);
                        this.stopSendLoop(); 
                        if (this.joystickManager) {
                            this.joystickManager.destroy(); // Destrói o joystick ao desconectar
                            this.joystickManager = null;
                        }
                    };

                } catch (error) {
                    console.error('Erro ao criar WebSocket:', error);
                    alert('Erro ao criar conexão: ' + error.message);
                }
            }

            disconnect() {
                if (this.ws) {
                    this.ws.close();
                    this.ws = null;
                }
                // onclose() vai lidar com o resto (parar loop, destruir joystick)
            }

            sendCommand(cmd) {
                if (!this.isConnected || !this.ws || this.ws.readyState !== WebSocket.OPEN) {
                    return;
                }
                this.ws.send(cmd);
            }

            testLatency() {
                if (!this.isConnected || !this.ws) {
                    alert('Conecte-se ao servidor primeiro');
                    return;
                }
                this.pingStartTime = performance.now();
                this.sendCommand('ping');
                this.latencyValue.textContent = '...';
            }

            updateStatus(connected) {
                this.statusDot.className = `status-dot ${connected ? 'connected' : 'disconnected'}`;
                this.statusText.textContent = connected ? 'Conectado' : 'Desconectado';
                
                const buttons = [this.btnQ, this.btnE, this.btnStop, this.btnTestLatency];
                buttons.forEach(btn => {
                    btn.disabled = !connected;
                });
                
                document.getElementById('joystick-zone').style.display = connected ? 'block' : 'none';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new RobotController();
        });

    </script>
</body>
</html>